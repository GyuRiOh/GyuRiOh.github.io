---
layout: post
title: 0420 내용
description: 0420 내용
summary: 0420 내용
tags: coding lesson quarter1
minute: 1
---



04 20

콜스택 ‘외부 코드’ -> 보고 싶은 경우는 ‘외부 코드 표시’를 활성화해야 한다.
디버거가 내가 짠 코드 이외에는 안 보여준다.
괜히 보여주면 정신없어지니까.
외부코드 표시를 활성화시키면 실제로 런타임 라이브러리가 되었든 DLL이 되었든 다 보여줄 것.
외부 정보의 도움을 받을 수도 있는데, 추가적인 확인 필요함.
pdb를 활용하고 뭔가 하다 보니까 아마 걔를 가지고 도움을 받는 것일 수도 있어서.

프로세스 잡아라. 디버깅하고 있는 상태에서 프로세스 잡을 수 있다고 말했음.
pdb맵핑이 안됨. 프로세스 연결로 잡아도 오로지 어셈블리로만 해야함.
함수이름도 안나옴. 주소값도 안나옴.
돌아갈 함수를 뒤집어놓은 상태에도 그 이전의 돌아갈 함수 주소를 가리키고 있다.
다른 외부 정보의 도움을 받아서 콜스택을 추적하고 잇는 것인가?
pdb를 맵핑 안시켜서 디버그해보려는 것.
소스코드는 아무것도 나오지 않을 것. 함수 이름을 보여줄 수는 없다.

while(0) 무한루프 넣은거. 돌고 있음.
“pdb도 없는데 콜스택을 어떻게 추적중인가?”
나중에 다시 논의할 것임.
콜스택이 형성되는거 자체가 런타임에서 호출될때마다 보여주는 것.
얘만 보고서는 확답 주가기 애매함.
일단 됐고.
일단 요런식으로 돌아가고 있고 만약 진짜 eip가 깨져버렸다면.
무한루프 같은데 빠져버리면 힘듬.
스택에 대한 변화를 많이 주었을 가능성이 크다.
우리가 알고 있는 무한루프랑은 다름. 무한루프라기 보다는 재귀스러운 건 아님.
ip레지스터를 잘못 건드려서. 돌아갈 코드보다 위를 지정하게 되버렸다.
리턴을 해도 또호출하고 또호출하고. 스택을 빠졌다 들어왔다 함.
이것을 분석이 된다면 esp 하단부에 내용을 뒤져서.
코드 영역스러운 지점을 찾아가면서 힌트를 찾을 수 있음.
@@그렇게 찾는 시도를 해봐야 함!!!!!@@

ebp건드리는건 실패했음. 컴파일러가 체크하는 코드를 넣어버림.

함수 파라미터 -스택에 넣고 있음. 어떤 순서로 넣을 것인가?
대부분의 함수는 오른쪽-왼쪽! R 2 L. 321 순서로 push push push 됨.
다른 변수나 상수 넣으면 상관이 없겠찌만.
어떤 함수를 통해서 그 리턴값을 활용하는 코드가 되었고.
그 녀석들 사이에 호출 순서에 영향이 있다면?
짱구를 굴려서 파라미터를 넣어야 한다. 근데 저렇게 짜지 않는다. 
누가 저렇게 짜면 같이 일을 하면 안 됨.
파라미터 활용할 때. 논의되어야 할 것은 스택에 넣는 것은 알겠는데.
실제 사용하는 측에선 어떻게 쓰느냐?

콜 들어가서 실제 함수 가보니까.
a밖에 사용 안했는데. a만 가고 있는데.

기존에 내 지역변수 같은 경우 ebp-로 갔었지만 
파라미터는 ebp+로간다.
내 함수 바깥에 있기 때문이다!!!!!!

내가 잡은 ebp 오히려 아래쪽에 있다..
그래도 이건 지역변수. 실질적으론 내 스택 아래쪽에 있지만 여전히 지역변수이다.
그래서 바깥쪽을 건드린다라는 것.

그다음 문제는 저 함수에 대한 스택을 누가 정리할 것이냐?
누군가는 저기에 psuh push push 되었던것을 정리해줘야 함.
얘는 여기 있습니다. 여기 있죠. call하고 나서 돌아온 자리서 add esp 0C를 해줍니다. 
add하니까 아래로 내려감 스택이. 요 psuh push push를 정리한것.
1)함수 좌측에서 정리한 것.
2)함수 내에서 자기가 파라미터에 대한 스택을 정리하고 나가는 방식도 있음. 

그래서 호출 규약이라는 것이 나옴.
호출규약은 위키백과에 정리가 잘 되어있음.
위키백과거 참고해보면. 뭐가 많은데. 대부분 잘 사용을 안 하기 때문에.
syscall은 커널모드로 전환되는 것. 우리는 대상이 아님.
우리는 대부분 사용할 수 있는 것. 일반적으로 사용하는 친구는 stdcall. cdecl을 활용함.
64비트. x86-64는 독특함. 호출자가 하는 것도 맞음.

레지스터 내 매개변수가 비어있다!! 
3개를 파라미터를 던질 떄 온전히 스택으로만 푸시푸시푸시했는데
성능이 떨어짐. 굳이 스택가지고?
그래서 다른 호출 규약들은 레지스터를 동원시키자.
어차피 레지스터 남아돌고있는데. 레지스터에 그 값좀 넣으면 안되냐?

그래서 그 레지스터에 온갖 것을 활용하는 경우.
파라미터. RDX, R8, R9 등을 사용하고 있음. 파라미터가 4개 이하라면 레지스터에 넣고 레지스터를 가지고 뽑아올 것입니다.
그리고 그 이상이 들어가면 어쩔 수 없이 스택을 ㅅ활용합니다. 무한대로 레지스터가 있는 것은 아니기 떄문에!

원래 호출규약이라는건 함수 문법이 어떻게 되냐?
윈도 API보면.

#include <Windows.h>

void WINAPI AAA()
{
}

stdcall.
함수 선언을 하기 위한 정식 문법은 저런 식.
리턴 지점과 호출 규약을 지정해서 정하기.
근데 우리 호출규약 아무도 안 쓰고 있어요. 그러면 어떻게 되느냐?

프로젝트의 속성 보면 
고급->호출 규칙 _cdecl. 
따로 지정을 하지 않는다면 컴파일러 옵션에 지정된 호출 규약으로 만들어준다.
호출하는 입장에서 파라미터 스택을 정리하는 것이다. 
콜 뒤에 esp를 밀어주는 코드가 있음.

그래서 stdcall을 실제로 사용하게 된다면.

_stdcall DDD(int a, int b, int c)
{
	a++;
	b++;
	c++;
}

RET에 인자가 들어감. -> 요게 스택을 정리하면서 나감.esp를 내리는 것.
피호출자 입장에서 파라미터 스택을 정리하며 나가는 코드가 됨.

64비트용 눈으로 보기.
레지스터에 정말 MOV할 뿐.
넘어가는 건 push push push 할 뿐.

함수 기능 만들 때 메모리에 대한 부분.
함수 호출 했을 때 그 안에서 동적할당 하네? 그 안에서 포인터 넘겨주네?
이거 쓰고 나서 delete? free? 아님 그냥 포인터 넘기고 쓸거 쓰고 버리면 되나?

@@뭔가 메모리 동적할당이 일어났다하면 그걸 생성하는 지점과 정리하는 지점이 같은 계층에 있는게 좋다.@@

그래서 그냥 포인터를 던지는 것.
안에서 내가 할당해서 뱉어줄게. 깔끔해서 해서 지워. -> 약간 위험성이 있다.
그런 관점에서는 _cdecl이 합리적.
stdcall로는 불가능한 것이 있다. 가변 인자.
함수 안쪽에선 절대 알 수 없다. printf같은 것.
그래서 x64같은것도 외부에서 정리하는 것으로 됨.
우리가 언제 함수 호출 규약 규칙을 따라야하고 생각해야 하나??

“호출 되는 코드와(하는 코드와)
해당 함수의 컴파일 환경이 다를 때!!! 또는 이미 만들어져 있을때!!!”

그런 애들은 이미 빌드가 된 상태. 어셈블리 코드로 함수가 다 만들어져 있음.
쟤네가 cdecl로 만들었는데 우리가 stdcall로 만들었다?
정리가 안 된다. 정리를 둘 다 하다가 문제가 생길 수 있다.

그게 한 가지 있고. 


나중에 윈api에서 이런거 나올텐데.

나중에 콜백이란 개념을 쓰는데
함수는 내가 만들지만 콜은 window가 해줄게란 것이다.
우리가 함수를 만들고 함수 포인터를 window에 등록을 시킬것이다.
window 내부에 콜하는 함수가 만들어져 있다.
니네가 만든 니함수 주소만 알려줘 호출시켜줄게. -> 호출은 stdcall로 만들었다.
그럼 우리가 stdcall로 만들어야 한다.

내부에서 할 거 다하고 내 코드로 함수를  호출해주는건데.
32비트는 stdcall로 만듬. 우리도 저렇게 해야 한다.
callback이나 winapi를 사용해야 한다. 그래서 #include <window.h>를 추가.

혼자 짤때는 호출규약을 공부해야 할 이유도 의미도 없는데
이런 상황에서는 주의가 필요하다.

void DDD(int a, int b, int c)
{
	printf(“%d %d %d \n”, a, b, c);

}

a = 0;
DDD(++a, ++a, ++a);

뭐가 들어가냐?
결과가 다르게 나온다.
표준에는 정의가 나오지 않는다.
윈도우에서는 333.
GCC에서는 321로 나옴. 
적당히 하나에 대해서 하는 것은 상관이 없다.

파라미터 할때 ++해서 던지는거 많이 쓰니까 이런건 상관이 없는 거고.
함수 호출 쪽으로는 이런 느낌으로 보면 되는거고.

구조체. 덩어리일 뿐이다.

구조체를 그냥 던지는 행동은 더러운 것. 
나중에도 실수하는 사람이 있음. 
그래서 먼저 조금 보여줌!!!
구조체같이 덩치가 큰 친구를 던질 때, 객체 자체를 던지지않는다.
콜바이 레퍼런스로 포인터를 던진다.
@@memset이 뭐지?? 0으로 밀어버리는 거.
xor eax eax -> eax를 0으로 만듬.

AAA a;
memset.
eax가 리턴값 받아오고 주는 것. 
알면서도 보면 그게 안 떠오름.
어 eax에서 뭘 받네? -> 눈에 익혀야 함. 함수 콜하고 eax에 뭘 받네? 그럼 리턴 받는걸로 인식해라!

구조체를 리턴 -> 정신이 나간 사람이다.
구조체 자체를 한번 리턴해보자. 절대 이렇게 쓰면 안 되는거지만.
만약 이렇게 쓴다면?
지금 보면 lea ecx, [ebp-178h]
파라미터 함수 호출되는건 rep mov해서 복사한거다. 
근데 함수호출전에 뭔가를 더 푸시해줌.

구조체 리턴할 때 그 구조체를 받을 공간을 하나 더 만들어줌.

반복문 rep movs . 4바이트 단위로 
카운터 반복문을 31번 돌림.
esi에서 edi로 ecx만큼 반복.

객체 자체를 파라미터로 받는 것은 절대 하면 안됨.
근데 특정 구조체가 멤버가 하나인 경우. 포인터 하나.
클래스 구조체인데 정말 멤버가 하나이다. 우리가 일상적으로 사용할 수 있는 멤버 하나.
이건 안다. 이거는 컴파일러가 일반 변수랑 동일하게 판단함.
엉망진창 이상한 구조체는 없어야한다.
최적화 컴파일을 하면 깔끔하게 해준다..ㅋㅋ

C 선행처리
undef -> 디파인을 취소시킨다.
한 cpp 안에서만 먹음. 
cpp10개 있는데 한 cpp에 define시켰다고 다른데 반영이 되지 않음.
조건부 컴파일. 

헤더를 하나 만들어 볼게요~
@@#pragma once -> 만약에 어딘가에서 실수로다가 인클루드를 한번 했는데 또 인클루드를 하면 중복선언이기 떄문에.
에러가 남. 그래서 2번 인클루드 하는 경우 밑에껀 무시할 수 있도록.
헤더에 헤더가 인클루드되다 보면. 어쩔 수 없음.

C의 표준 정석대로 가다보면.. 우리가 항상 이걸 쓰죠.

#ifndef AAAAAAAAA
#define AAAAAAAAA

#endif

속성->전처리기 . 전처리기 정의에 뭔가 하면 모든 cpp에 정의를 한 것과 같은 효과.

게임 컨텐츠 - 글로벌 서비스.

“원 빌드로 모든 국가를 대상으로 서비스 하기를 원한다 : 모든 개발자!”
물론 그 게임 안에 언어만 바꾸면 딱 설정이 되도록.
그거 보면 전세계 사람 다 만난다.
정말 그 빌드 하나를 가지고서 하고 있다.
대부분 mmorpg는 못한다. 현지화를 해야 한다.
국가별로 서비스하기 위해서 코드를 따로 파는 경우가 많다.
그래도 어느정도 선에선 하나의 코드가 좋다.

그러면 그나마 그래도 하나의 프로젝트 코드에서 이국가용 저국가용으로 코드를 분리하고 싶다 할때도
ifdef를 쓸 거다,

#ifdef kor
#endif 
#ifdef JPN
#endif

이렇게 되는 것. 
이런식으로 하기 때문에 글로벌서비스 하는 게임은 전처리기. 이프디파인이 많이 활용이 될 것.
나머지는 적당히 해 주면 됨.
매크로함수도 적당히 봤으니까 됐고.

조건부 컴파일. 

@시스템 정의 매크로@!!!!!!
__DATE__, __FILE__
__LINE__ __TIME__ 
이건 전처리기에서 처리되기 때문에 런타임이 아니라 컴파일시간에 하드코딩이 되어버린다. 상수로서
현재 파일의 이름이 나온다. 
이거를 정말로다가 printf(“%s”, __FILE__);
이러면 경로를 뱉어낸다.
%d, __LINE__ -> 정수로 나온다.
데이트나 타임은 쓸일이 별로 없는데. 라인과 파일은 우리가 쓸 일이 좀 있다.
나중에 로그같은걸 만들 때 활용할 일이 있을 것이다.

얘는 별도의 타입을 만든다는 의미로 가는 것.
단순한 치환을 하는게 아니라 타입을 한다는 의미로 가는 것.

switch case-> 메시지 종류대로 디파인 함.

enum
{Move = 1, ATTACK, SKILL
AAAAA = 10, BBBB, CCC
}
위에서 지정한걸 그냥 1더하기로 넘어감.

enum은 구조체처럼 타입을 지정할 수 있다.

enum방식을 쓰지 않고 아까처럼 #define을 사용했다면?
액션을 요렇게 무브 1 스킬 3 이렇게 해보고. 함수 만들어야지~ 액션~
void Action(int ActionType)
{
	switch (ActionType)
{
	case move: 
		break;
}
}

enum 자체를 하나의 타입처럼 사용할 수 있다.

이상한 수 인자로 못 넣게.
void action (enumAction ActionType)

enum이 중복정의 되어서 에러를 뱉어냄.

대부분 게임들이 대역을 나눈다.
저 메시지만 봤을 때 무슨 메시지인지 보인다~
메시지 번호만 봐도 뭐구나 보인다.
enum으로 했을때 보기 불편한 건 있는데, 해선 안되는건 아니다.

@@함수 포인터 -> 그냥 진짜 함수 포인터.
그 주소를 저장할 수 있게 문법적으로 지정.

이런 함수를 받아들일 수 있는 함수로서 선언합니다 ~ 함수 포인터.
함수 포인터 선호하는 사람은 많이들 선호한다.

우리가 메시지로 한다 하면 1:1로 대응되게 함수를 묶을 것이다.
Proc1() 처럼 묶을 것.

switch를 함수포인터 배열로 커버할 수 있다.

void(*ptr[10]) ();

ptr[1]  = proc1;
ptr[2] = proc2;
ptr[3] = proc3;

ptr[ActionType]();

이러면 스위치케이스를 1줄로 줄여버릴 수 있음.
근데 이러면 디버깅하기 불편. 뭐가 호출될지 모른다.

[const int*p
int const *p] 같은 것. 값을 바꿀 수 없음.
const는 *에 쳐진 것.
const *p = &a;
const *p

p=&b


int * const p
const가 p에 들어가서 값은 변경할 수 있지만 대상은 변경할 수 없다.


차이점을 보자. 

분석할 때 불안하다. 뭔가 건드릴까봐.
그럴 때 const 선언을 해서 받아줘야한다.
그래야 안에선 안 건드릴것이라는 사실이 확정되었끼 때문에.
쓰는 사람들이 마음이 편해질 것이다.
그래서 포인터를 받거나 C++의 레퍼런스를 인자로 받을 때는 무조건 const를 해야한다.
쓰기 목적 아닌 읽기 목적으로 받을 때는 무조건 const.
무조건 몸에 배어야 한다. 협업을 할 때 좋은 습관이기 때문이다.

코드 다시 살펴보면서 뭔가 실수한 거 있나? 하고 볼때 처리하면 좋다.
“오 이거 믿음이 간다~” 라는 인식이 생길 수 있음!

strlen strcpy strcmp
문자열 복사, 길이 확인, 문자열 길이 비교 -> char const* 함.
