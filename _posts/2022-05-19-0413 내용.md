---
layout: post
title: 0413 내용
description: 0413 내용
summary: This page tests jekyll headers.
tags: coding lesson quarter1
minute: 1
---

22. 4. 13


우리는 이제 32비트 프로젝트를 잘 사용하지 않음. 
64비트 프로젝트로만 작업을 하게 될 것이다.

릴리즈 모드라서 디버깅이 되지 않는 일은 없다.
디버거는 프로세스를 잡고 디버깅을 해버리는 것이다.
모든 프로세스를 다 잡고 디버깅할 수 있다.

Q, 릴리즈를 해두고 F5를 눌렀는데 되지 않는다?
-> 디버깅이 안 되는 것이 아니고, 소스코딩이 되지 않았기 때문에 브레이크 포인트가 걸리지 않는다.
애초에 소스 코드가 사라지면 브레이크 포인트를 걸 대상이 없어지기 때문이다.

우리가 보는 디버깅 = 내가 짠 소스코드와 어셈블리를 매핑시켜서 디버깅하는 것.
그렇다면 매핑에 대한 작업을 누가 어떤 정보로 수행하는가?

디버그 정보 생성을 no로 만들면 디버깅하지 못한다.
브레이크포인트를 걸고 조사식으로 변수를 확인해야 한다.

100%동일한 소스코드를 디버깅 할 때도
프로그램 데이터 베이스 파일 (program database file, pdb)가 필요하다.
매핑 정보를 pdb로 보기 때문이다.
만일 pdb가 없더라도 어셈블리로 디버깅을 수행해야 한다.

프로그램 생성 조건 -> pdb가 나옴.
pdb가 나온 건 디버깅이 된 것이다. 
pdb가 있어야만 디버깅이 가능하다. 게임을 라이브서비스 할 때에는 pdb를 항시 보존시켜야 한다. 이는 빌드할 때마다 버전이 다르게 들어간다.

만일 pdb가 없으면 소스코드가 똑같이 있어도, 매핑을 시키지 않는다.
새로 빌드해버리면 다른 코드로 인식해버린다.
같은 시점에 나오는 pdb가 없어져버리면 힘들다.
비주얼 스튜디오를 쓰지 못하고 윈디버거 등으로 수행해야 한다. 텍스트로만 디버깅해야 해서 골치가 아프다.

Q, 브레이크가 안 걸린 이유?
A. 속성 C++ 최적화 때문. 최대 최적화로 현재 옵션이 들어가있음.
최대 최적화란 ‘맘대로 결과를 갈아엎어버릴게. 필요 없는 건 지울게. 변수도 내 맘대로 바꿀게. 함수도 없앨게.’ 라는 선언.
릴리즈모드에는 기본적으로 속도 최적화가 걸려있어 내가 쓴 코드와 다른 결과물이 생성된다.
그래서 브레이크가 안 걸린 것처럼 보인다.

안 쓰고 있어서 호출하지 않아도 되는 함수 <= 없어진다!

최적화가 되면 내 코드와 완전히 다른 결과물이 탄생한다.
대부분 브레이크가 걸리지 않는다.

최적화에서 ‘사용 안함(/Od)’으로 바꾸면 디버깅이 가능하다.
기본적으로 개발을 할 때에는 릴리즈모드에서 최적화를 끈 상태로 이행한다.
이렇게 하면 내가 짠 코드만 그대로 어셈블리 명령어로 나타난다.

주소 표시 = 명령어가 위치한 메모리.

test = && (0을 확인)
eax 레지스터 리턴 값을 이용한다.
컴파일 언어에서는 리턴 하고 안하고를 결정하지 못한다. 리턴값 있으면 무조건 리턴해야 한다.

Xor = 비트 단위로 같으면 0, 다르면 1 -> 0을 만들어 버린다.
Xor eax, eax는 대표적으로 eax를 0으로 만들어주는 코드이다.

cmp = 비교. 차를 구한다.
cmp ebp esp -> 차를 구해서 두 값이 같은지 알고 싶은 상황이다.
만약 서로 다른 값이 나오면 이를 문제삼는다.

jne = jump not equal 같지 않으면 점프한다.

sub esp 하나로 모든 지역변수의 크기 확보를 끝낸다.
선언과 동시에 초기화 vs 선언 하고 초기화 => 같은 것!! 차이가 없다.
어셈블리 단계에서 변수의 선언이란 존재하지 않는다.

<클래스 인스턴스>
1. 메모리 확보
2. 생성자 호출

블럭으로 문법을 막아둔다.

volatile : 멀티스레드에서 언급된다.
물리 메모리에 더 쉽게 접근하기 위해 캐시 메모리가 존재하는데,
volatile이 캐시 메모리를 건너뛰고 물리메모리에서 값을 가져온다는 것은 잘못된 설명이다.
“캐시를 사용하지 않게 한다” <- 뇌자극 책 설명.
“그냥 최적화 컴파일을 하지 않는다!” 딱 이것 하나 한다. no register와 같은 의미.
최적화 컴파일을 끈 상태 = 모든 변수에 볼레타일을 단 것이나 다름이 없음.

그렇다면 캐시라는 표현은 어째서 존재하는가?
eax를 캐시로 쓴 것이다. 그냥. ‘캐시 메모리’가 아니다!
캐시라는 표현이 모호하기 때문에 쓰지 않는 것이 좋다.

*최적화 컴파일 장점 : 속도가 빨라진다.
릴리즈에서는 안전 장치가 제거되어 속도가 빨라진다.
디버깅 안전장치들이 빠지고, 최적화 컴파일이 수행되면 성능향상이 꽤나 있다.
코드를 깔끔하게 잘 짰다면 조금, 더러우면 많이.

*최적화 컴파일 단점 : 문제 해결이 느리다.
다만 그 속도의 향상을 포기할 수 없다는 회사도 존재한다.
그냥 당연한 줄 알고 릴리즈로 하는 회사도 존재한다.
그런 회사의 특징은 문제가 터져도 분석하지 못한다는 점이다.

속도적인 컴파일은, 코딩을 애초에 잘 하면 괜찮다.
어셈블리가 예쁘게 나오도록 코딩을 하자!
예쁘게 나온다는 것은 어셈블리가 빠르게 나오도록.

inline 처리 -> 함수 호출이 무겁다. 
호출할 때마다 스택에 넣고 넣고 들어갈 때마다 빼고 빼고.
C++에 inline 키워드 -> 최적화 컴파일을 하면 의미가 없어진다. 알아서 가능해진다.
inline을 했어도 최적화 컴파일을 끄면 인라인 처리는 수행되지 않는다.

검증이 되지 않은 코드는 inline 처리를 하지 않는 편이 좋다.
검증이 되면 할 수 있는데, 검증이 된 서버 자체가 존재하지 않는다.
온라인 게임 서버는 영원히 개발 중 디버깅 상태에 있다.
계속 디버깅을 고려해서 개발할 수밖에 없다.

만일 무조건 최적화 컴파일을 해야 하는 상황이라면,
그때서야 써볼 수 있는 것이 volatile이다.

최적화 컴파일 했고 뭔가 문제는 터졌다? 
유저가 어떤 행위를 할 때 문제가 터지더라 하고 범위가 좁혀졌다면, 그나마 의심이 가능하다.
거기에 관련된 변수나 기능, 의심되는 부분을 volatile 선언한다.

그렇게 하면 내가 짠 로직대로 어셈블리는 실행될 것이다.
inline처리 해도 내가 짠 로직대로 어셈블리는 나온다.

로그 찍을 때.
디버깅할 때도 로그를 많이 활용한다.
어떤 함수 안에서 디버깅하는데 최적화 컴파일 중에 변수가 조사식에서 보이지않는다.
여기서 변수가 어떤 값일지 궁금한데 값을 알 수 없다면,
그 변수를 volatile 선언한다.

중간에 디버깅 목적으로 volatile 변수를 추가할 것이다.
보존을 위하여.
멀티 스레드 환경에서 volatile을 사용하면 나의 의도대로 로직이 보존되기 떄문이다.

const int a;
const 상수 -> 어셈블리에서 a를 쓰는 모든 지점이 ‘10’으로 치환되었다! 

32bit/64bit

ILP64
LP64 포인터 8 유닉스
LLP64 롱롱 64비트
SILP64 숏부터 64. char 빼고는 모두 8바이트화 시켜버린다.

64비트 데이터 모델은 위키백과에 검색하면 나온다.
규칙만 이해하면 된다.

short 자료형 : -32768 ~ 32767.
65535라는 숫자도 외워두자.

우리는 돈, 경험치 모두 64비트로 한다.
그 외에 변수는 4바이트를 사용한다.
포인터를 썼을 때, 메모리 크기가 조금이라도 바뀌면 오작동한다.
뭔가가 하드코딩 되었거나 잘못된 것이다.
변수 하나 크기가 바뀜으로써 어떤 문제가 발생하지 모른다.

버그 나오면 ‘프로세스에 연결’ 하기!!


