---
layout: post
title: 0415 내용
description: 0415 내용
summary: 0415 내용
tags: coding lesson quarter1
minute: 1
---


2의 보수란? 비트를 전부 반전시키고 +1.

char ch = ‘a’;
문자라는 것은 없다. 아스키 코드가 저장되었을 뿐이다.
출력했을 때 a가 보인 것 뿐!
출력했을때 char로 출력하면 a, int로 출력하면 65가 나오는 것이다.

규모 있는 회사의 규칙은 : 변수 선언을 무조건 한 줄에 하나씩 한다.

포인터를 선언할 때.
int *p;
int *p1, p2, p3; //p2, p3은 포인터가 아니다.
int *p;

이상한 건 쓰면 안 된다.

“연산자 우선순위는 암기하자!”
연산자 우선순위 관련한 문제가 자꾸 나오고 있따.
거의 백프로 틀린다.

단항 연산자, 증감 연산자, 전위 후위의 특성은 필요가 없다.
++a, a++ -> 일반 변수의 경우 그냥 어셈블리 순서를 바꾸는 것으로 해결이 가능하다.

CPU에 아웃 오브 오더링이 존재한다.
어셈블리 명령어가 조건에 의해서 처리되는 순서가 바뀌는 것이다.
CPU가 128개 이상의 명령어를 버퍼로 끌어와서 미리 진행해버리기 때문이다. 
먼저 처리할 수 있는 연산은 빨리빨리 해버린다.
즉 명령어 처리 순서가 바뀐다. 이것이 아웃 오브 오더링 익스큐션이다. (=명령어 재배치)
이는 멀티스레드 할 때 깊게 진행해볼 것이다.

비트 &연산자의 활용 용도? : 비트를 날려버릴 때.
(하위 비트를 날려버림으로서 8의 단위, 64의 단위 등을 맞춰줄 수 있음)

>>, <<연산도 예전에는 많이 사용했다.
맵의 크기를 계산할 때 2의 n승으로 크기를 잡는다.
어떤 좌표가 있을 때, 그 좌표에 대한 타일 좌표를 구하려면?
서버에서는 그리드, 타일 방식을 사용한다.

하지만 이제는 >>, << 방식을 사용하지 않는다.
>>, <<가 나누기, 곱하기라는 생각을 하지 않기에 권장하지 않는다.
아 그래도 나는 배운 것을 써먹고 싶다~ 라면 주석을 꼭 달아두자.
곱하기 몇. 이건 이런 의도다 라는 점을 반드시 알려주자.
반복문이 아까워서 풀어 썼던 시절에 사용했던 방식이다.

*3항 연산자 : if문이 빠른가? 3항연산자가 빠른가?

jne => jump not equal. 0이 아니라면 튀겠다.
3항 연산자는 tmp를 낀다. ex) a++
그래서 if문을 사용할 때보다 더 느릴 수 있다.
더 빠르지는 않다. if는 tmp를 끼지 않는다.
하지만 이러한 부분은 컴파일러에 의해서 달라질 수 있다.

항상 검색으로 해결하려는 태도는 지양해라.
검색으로 나왔어도 뇌피셜일 수 있다.
그냥 눈으로 보고 판단해라. 그게 정답이다.

*16진수 출력의 2가지 방법
1. %x -> 그냥 변수가 가진 16진수만 튀어나옴.
2. %p -> 포인터 주소 값을 출력하는 것이 목적이다. 주소값을 채우기 위해 8개의 16진수가 출력된다.

sizeof 연산자는 상수로 바로 저장되어서 하드코딩된다.
런타임에 수행되지 않는다.

AND 논리 연산자가 중첩될 때 : False가 나올 가능성이 높은 것을 왼쪽에 두어야 한다. (그래야 연산이 조금이라도 빨라짐)
OR 논리 연산자 중첩될 때 : True가 나올 가능성이 높은 것을 왼쪽에 두어야 한다.

&&연산자 : 어셈블리 cmp와 대응된다.
cmp는 두 피연산자를 비교한다.
cmp에는 zero flag라는 것이 있는데, 초기값은 NOT ZERO(NZ)로 0이다.
cmp결과 두 피연산자가 같아서 0이 튀어나오면 zero flag는 1로 세트된다.
반대로 두 피연산자가 다르다면 zero flag는 그대로 0으로 남아있는다. 

&연산자 (비트단위AND) : 마스킹할 때 주로 사용.
네트워크에서 IP주소 세팅 시 사용한다.
IP, SubnetMask, Gateway
(a&0xFF00) >> 8

^연산자 (비트단위XOR) : 암호화/복호화할 때 주로 사용한다.
XOR연산자를 2번 사용하면 원상태로 복원된다. 

예를들어 기본 바탕에 그림이 있고, 커서가 움직일 때마다 그 자리를 표현해줘야 하는 상황.
좌표가 바뀌고 있으니 항상 새롭게 렌더링해야한다. 바탕 찍고 커서 찍고? 비효율적.
XOR로 그림을 그리면 어떤 그림이 하나 있는데, XOR찍으면 색깔이 나온다.
이걸 지우려면 XOR로 한번 더 찍으면 된다. 그럼 복원된다.
과거 좌표 XOR / 새 좌표 XOR

명시적 형변환 : 캐스팅은 하는 일이 없다. 실질적으로 존재하지 않는다.
컴파일러에게 "이건 내 의도야, 오류내지 마~" 라고 지시해주는 역할이다. 포인터도 마찬가지이다.
단, 실수형과 정수형의 변환은 실제 함수호출이 일어난다. 데이터 타입이 아예 다르기 때문이다. 
이 건을 제외한 모든 캐스팅은 사실상 없는 것이다.

switch문 : 네트워크 할 때 어마어마하게 들어간다.
서버가 유저가 보낸 메시지 타입에 따라 분기를 타기 때문이다.
MMORPG 규모 있는 컨텐츠라면 메시지 종류만 수백개이다.
근데 극혐하는 사람이 있다. 
1) 너무 길다.
2) 성능 떨어질 수 있다. 마지막 분기까지 가려고 수백개를 if cmp해야 할 수도 있으므로...
이러한 이유로 자료구조 hashtable 등으로 치환시키기도 한다.

그래서 이게 언제 분기를 타고 안 타는지 알아야 한다.
우리는 분기를 '타지 않게' 만들어줘야 하기 때문이다.
무작정 만들면 cmp를 500번동안 돌리는 상황도 만들어진다.
분기를 타지 않을 경우, 점프 테이블이 생성된다.
이때 첫번째 case(상수)가 기준이 된다.
case상수의 최대치를 초과하면 밖으로 나가버린다. (ja 명령어)
함수 포인터 배열 처럼 만들어진 것이다.
만일 case값 사이에 간격이 존재할 경우, 그 사이를 밖으로 빠져나가는 것으로 채운다.
case값을 역으로 하나씩 줄어드는 식으로 하면?
분기문 나오면 cmp가 뜬다.

그래서 언제 분기를 타는지?
너무 case값 사이의 크기차이가 크면 cmp를 계속 한다.
테이블 자체가 사라진다. 
