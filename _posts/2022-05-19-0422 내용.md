---
layout: post
title: 0422 내용
description: 0422 내용
summary: 0422 내용
tags: coding lesson quarter1
minute: 1
---


atomic한 행동이란?
atomic 한방에 실행된다. 이 명령 끝나기 전까지는 누구든지 개입을 할 수 있다.
크리티컬 섹션 동기화는 완전 다른 건이다!!
크리티걸 섹션이 동기화되어도 스케줄러는 쓰는 겁니다.

권한을 얻기 보다는 내가 여기에 접근을 했으니까 그쪽 스레드를 블락하겠다.
아토믹이랑은 상관이 없는 행동.

뭘쓰던 커널모드 전환이 이루어져야 한다.
커널 오브젝트 안쓴다.
프로세스간에 접근할 일이 없다.
프로그램 종류에 따라 다르지만 게임서버는 프로세스로 나누어 기능을 분리할 이유가 없다. 스레드 기능을 분리했다? 서로 다른 프로세스로 기능을 분산하는 목적은 부하분산.
최종 결과는 물리적으로 하드웨어가 다르다. 그럴려면 애초에 물리적으로 하드웨어 서버를 분리할 것까지 고려한다면
커널 오브젝트가 아니고 네트워크가 됨.

— 본 수업 시간 —

함수 호출 스택 : 돌아가는 주소와 백업된 ebp 2개만 사용함. 
걔만 날리면 다 깨짐.
스레드 동작이 궁금하다. 스케줄링을 어떻게 하냐가 궁금한건가?
앞 함수의 ebp 백업 <- push ebp

재귀함수 - 계속 사용하면
스택메모리가 찬다.
계속 스택을 쌓아가기 때문에 언젠간 스택의 1M를 다 사용한다.
탈출조건이 없으면!!

런타임 스택 오버 플로우가 발생합니다 <- 확정된다.
저런 빌드를 안내게 재귀를 만들려면 어떻게 해야한다?
재귀는 확인 해야함. 
재귀가 위험한건 아니다.
대신 조건을 만족한다 - 재귀를 중단할 수 있는 코드가 들어가야 한다.
걔만 들어가면 어떤 리턴의 상황. 
파라미터를 받고 , 어떤 조건이 되었을 때
x > 1000000
return;
조건으로 중단하고 나간다면. 
얘가 보기에는 크게 문제가 없어보인다. 경고를 내지 않는다면.

몇번을 호출해야 스택이 터지는지 살펴보자.

A에 파라미터 1을 넣고. 
스택을 100바이트 잡았으니까.
스택에 통통통통 늘 것이다.
디버그빌드에선 정말 몇번 못돈다. 
지역을 너무 많이 잡는다.
85631돌고 나서야 재귀를 돌고 터졌다. 

트리같은거 만들때 100프로 재귀를 쓴다. 안전하기 때문에!
트리라는 구조 . 깊이. depth. 이진트리에서 깊이가 하나씩 늘어난다.
하나->2개->4개->8개… 
저렇게 8만5천건은 할 수 없겠지만. 트리라는 구조에서 재귀를 탐색하는 구조 만들었는데,
불안정하면 2^800000 개수가 있다는 조건. 
1억 2억개를 넣더라고 재귀는 터질 일이 없어.
잘만 만들고, 정확히 계산된 대로만 했다면 문제될 게 없다.

재귀를 사용하는 근본적인 이유?
반복문 - 비교와 연산.
재귀 - 그 앞의 함수의 스택이 살아있다. 앞의 상황에 모든 상황들이 기억되어 있다.
값을 기억한다. 그 상황에서의 모든 지역변수들이 기억되었다. 
반복문은 단방향. 트리같은 경우는 돌아가야 한다. 어디서 왔는지를 알아야 한다.
“돌아갈 길”
그것을 지역에 두고 스택에 쌓아둔 것.
그걸 그대로 쌓아둔 상태에서 다음 코드가 돌아가니까.
리턴만 해도 앞의 모든 상황이 기억된 경우.

그게 아니면 재귀를 쓸 이유가 없다.
그냥 조건 체크해서 반복하는게 좋다.

재귀는 호출을 해서 올때마다 5번 왔다면. 그 상태가 저장이 된 것.
돌아가면 이전의 상태로 갈 수 있다. 스택을 활용해서!!!! <- 이게 장점이다.

모든 재귀는 반복문으로 다 바꿀 수 있다.
별도의 자료구조를 통해서 저장해야 할 공간을 스택처럼 다른 공간에 기억한다면 모든 재귀는 없앨 수 있다.
결국 그 스택을 우리 자료구조로 갖고온 거니까.

재귀라는게 있으니까. 

–

이 픽셀과 이어져있는 구간만 색칠을 하자. 얘는 반복문으로 불가능하다.
어디서 어디로 이어졌는지 알 수가 없다.

나중에 길찾기도 똑같고…
최적의 탐색 알고리즘이 되는 것.
A*알고리즘 쓰는 거?

지금은 길을 찾는게 아니고 무작정 퍼지는 것.
의도는 그거 하나.
그냥 칸칸칸이 있는 상태에다 쳤을 때. 여기에서부터 이런식으로다가 퍼져나갈 대상이 막혔다고 가정한다.

퍼져나가야한다. 위칸 아래칸 옆칸. 어 여기는 못가네? 하면 안 갈거기 때문에.
정말로 여기 좌표를 기준으로 시작한다면
자기 주변에 색깔 칠하고 퍼진다.
반복문은 하나의 방향으로 쫙 갈 뿐이지만, 재귀는 하나의 좌표가 있으면 4개의 자식들이 생긴다.
깊이 우선 탐색!!
무조건 4개씩 퍼져서 색칠을 해나간다.

화면 지우는거 system(“cls”); 
너무 속도가 빠르면 슬립을 쓴다. 윈도우 API!!
sleep. 속도를 늦추고 싶을 때. 
윈도우 헤더 해야 함.

밀리세컨드 ->
슬립은 고차원적인 함수. 스레드 함수.
C언어에는 멈춘다는 개념이 없다. 언어주제에 못 멈춘다.
내 코드가 멈춘다? OS의 개입이 있어야 한다.
우리가 잠깐 프로그램 속도를 멈추고 싶을때. 
쟤의 구체적인 행동은 우리가 스레드를 다룰 때 할 것.

다음시간에 이놈에 대해서 논의하면서 알고리즘 공부 해 볼 것.

@@포인터!!!@@

포인터 - 메모리 주소 저장. os 이름 따라 간다
인식할 수 있는 최대 메모리는 4G. 2의 33승(unsigned int)
32비트는 가능하다.
근데 64비트는 안된다.
unsigned long. unsigned int라는 공간에 포인터 주소값을 저장해서 넘기던가. 이런걸 많이 했다.
예전에 윈도우 api도 그렇게 나왔었다.
unsigned long 형태의 파라미터에 포인터를 넣는 것을 활용했다.
잘못되었다. uint_ptr로 바뀜.

우리가 당연히 프로그램을 잘만 짰으면
32비트로 서비스 된거는 그냥 프로젝트를 64로 바꿨을 때 문제생길일이 없어야 한다.
표준에 있는대로 썼다면. 근데 대부분 문제가 터진다.

윈도우 서버버전은 이제 32비트가 안나온다.
당연히 64비트로 개발하는게 당연한건데 32비트로 만들어진 게임서버가 많다.
우리가 동적할당해서 쓸 수 있는건 2G가 한계. 이거 다 한계치에 도달했음.
메모리가 부족해. 더이상 추가할 수 없어.

최대한 컨텐츠 안쓰는 것 정리하자. 64비트로 바꿀 수가 없으니까.
메모리는 증가하게 되어있다.
동접자를 줄여서 해결했다.

메모리 확보를 6개월 해서 300메가, 400메가를 확보했다.
계속 로그추가하고. 안쓰는지 보고 이거로 인해 영향이 없는가 보고.
덜렁 지워버릴 수 없다.
뭔가가 밀려서 또다른 문제가 터질 수도 있다.
sizeof를 하지 않고 그냥 define해서 하드코딩하는 코드가 있을 수 있다.
그래서 걔를 주석으로 막고 그거에 관련된 변수에 로그 심어서 정말 호출조차하지않는지 지켜본다.
그 메모리를 지울 수 없으니까. 걔랑 크기 똑같은 형태로 버퍼. 영향주지 않게.
이렇게 해도 문제가 없는지 기다린다.
일단 이 변수가 지워졌음에도 불구하고 빌드 되니까.
이거로 인해 외부에 다른 영향 없는지.
여기에 접근하는 코드는 있나. 특정 값을 밀어넣고 바뀌는 코드는 있나 확인하기.

왜 리틀 앤디안을 쓰는가? 0x00001 있을 때 뒤에서부터 읽어야 유효값을 읽을 수 있다.

우리가 배열을 쓴다?
2차원 배열 -> 게임에서 사용.
sin cos 라디안 값 넣게 되어있음.
물리게임 만들때 사인 코사인 지금은 때리는데
도스시절은 런타임 금지. 너무 느려서.
느린걸 빠르게 만들기 -> ? 베이킹 : 미리 작업 해두기. 실시간 연산이 느리면, 미리해두면 가져다 쓴다.
메모리를 포기하고 실행속도를 높인다! 성능을 높이겠다는 건 이걸로 된다.
길찾기 느리네? 미리 테이블 만든다. 사인코사인 느리네? 테이블 만든다.
sinTable[360], cosTable[360]
이것도 연산을 빠르게하기 위해 데이터를 해놓은 것.
게임에서 어마어마하게 커다란 필드가 있다.
이 안에 오브젝트들이 무수하게 많이 있는데… 온갖 것들이 다 있다.
2000마리의 오브젝트가 있다.
바닥에 아이템이 수천개 있다.
일반적인 rpg게임 만든다. 아이템 먹는 기능?
충돌 체크-> 움직임이 있을 때마다. 어떤 오브젝트와 충돌 되었는지를 하나하나 뒤져야 한다.
오브젝트가 많아지면 많아질수록 성능은 급격하게 떨어진다.
이를 오브젝트 개수와 상관 없이 한방에 해결하려면?
이 자리에 누가 있는지 한방에 알아버리면 된다.
내가 서있는 이 자리에 누가 있는지 한방에 알아버리자.

솔루션 ) 그리드로 나눠버리자. 일정 규격의 타일로 나눠버린다.
아이템이 떨어진 타일에 정보를 꽂아버린다. 포인터를. 
무조건 mmorpg는 그리드 방식을 쓴다. 이건 커다란 2차원 배열이 나오는 기반으로 가는 것.
논타겟팅 마법을 해. 동그랗게 여기에 있는 애들이 맞아야해.
하나하나 좌표 체크 못한다.
논타겟팅의 공격 -> 그리드 방식으로 처리. 이렇게 하지 않으면 성능을 낼 수 없음.
이럴 때도 이차원 배열 많이 쓸 것.

aI -> if else.
이 분기 많은데 어떻게 예쁘게 하느냐? 로 방법이 나뉜다.
여기서 분기문의 방식이 관리 안되니까. FSM. 상태머신.
객체화 시킨다. ifelse를 클래스로 객체화 시킨다.
무수히 많은 스위치케이스를 클래스로 묵는데. 이프엘스랑 같은.
비헤이비어 트리. 언리얼이 쓰고 있음. 행동 트리!! 트리로 만든것 그냥.
결국은 이프 엘스. 옛날 방식에서 ai는 무수히 많은 이프엘스를 배열로 한 것.
특정한 상태의 개수를 딱 딱 뽑아낼 수 있다면 배열로 만들 수 있음.
나의 HP, 적 HP, 거리. 아군 수. 이런 요소들을 반영하고 싶음.
4개 요소만 된다 해도 조건 많아짐

AITable [5] [5] [4] [3] -> 오토마타. 이 테이블 만드는게 힘들다. 이건 기획자한테 넘김.
근데 요론거 이제는 구식. 스타도 이렇게 구현한다. 다차원 배열!!!

구조체. 구조체 할 거 많다!

typedef -> struct 키워드 빼버릴려고 하는 거.
근데 이건 사라졌다. typedef는 쓸 일이 없는 것이다.

구조체 데이터 패딩 -> 구조체에서 제일 크기가 큰 자료형 기준.
가장 큰 변수랑 상관이 없이 보아야 한다.
그건 다른 조건.
그냥 자기 크기다. 자기 크기에 경계에 서야함. 
자기 크기 하나. 캐릭터는 1바이트이니 어디에나 서도 됨.
변수가 선언될때 내 앞에 패딩을 몇개 붙일까 하는거. 뒤가 아니다. 앞.
내가 몇 바이트니까 내 앞에 몇을 붙일까.
캐릭터는 내 앞에 패딩이 안들어간다.
쇼트는 0,2,4,8,10,12 로 들어가야한다. 내 앞에 캐릭터 있으면 1 들어간다.
내 앞에 4로 떨어지면 안들어가도 된다.
인트. 내가 4에 서야 한다. 
캐릭터가 하나 더 붙었다. 얘로 인해 내가 4의 경계에 못서기 때문에 3바이트 패딩 넣어야 한다.
‘나’를 위해서 하는 거니까. 내 앞에 패딩을 넣는다고 생각해야 한다.
__int64는 8의 경계에 서야 한다.
모든 변수는 자기 크기의 경계에 서야 한다. 그렇게 해야만 한다.
지역변수 전역변수 모두 동일한 규칙이다.
그런데 일반적인 변수로 할 때는 생각한 적이 없다. 생각 안해도 되니까. 문제가 안 되니까!
구조체 때는 크기가 달라지니 고민하는 것이다.

근데 가장 큰 변수 -> 나의 전체 크기.
이 구조체의 전체 크기. 뒤에 붙이는 패딩에서의 이야기.
@@이 구조체 안에 8바이트짜리 덩어리가 있었으면 8로 떨어져야 한다.??@@

근데 이렇게 하는 이유가 뭘까?
변수가 차지하는 메모리 공간을 온전히 읽어오기 위해서…?
왜 그렇게 읽게되는거죠? 
1)한번에 처리하는 단위가 4바이트/8바이트라서?
2)캐시메모리에서 짤릴 수 있기 때문. 멀티스레드 환경에서 캐시메모리에서 짤려버리면 코어 여러개에서 접근을 할 수 있다?

지금 우리가 실질적으로 단순히 사용하는 입장에선 아무 상관이 없다.
저 패딩 밀어버릴거다.
패딩이라는 규칙 자체는 프로젝트 속성 -> 코드 생성 -> 구조체 멤버 맞춤 설정가능.
이걸 1로 바꾸면 모든걸 1로 맞춤.
pragma pack이라고 할 수 있음. 네트워크 환경에선 1바이트 단위로 모두 바꿀 것이다.
성능을 위해 패딩을 붙여준거기 때문에 네트워크 프로토콜에서는 크기가 제일 큰 문제.
네트워크 프로토콜이란? 이쪽 장치와 저쪽 장치가 서로 통신하는 환경인데. 
서로 규격이 안맞으면 안됨.
그땐 의도적으로 #pragma pack 써서 1바이트로 바꿔버릴것.
구조체 선언만을.

근데 만약에 저런 2바이트나 4바이트 짜리가 얘의 경계에 사지 않았다면.
CPU가 읽어오는 행동이 2번 이상이 될 수 있음. 약간의 성능 저하 발생! 
메모리 번지에 접근이란건 1 2 4 8 16. 
17에 접근한다 없음. 그 단위로 읽어들일것이다.
메모리에서 버스에서 접근할 때. 저 램에 있는 메모리에서 뭔가 긁어온다라는 모든 행위자체도.

무조건 캐시라인 단위로 긁어온다.
우리가 실질적으로 변수 읽을때 걔가 있는 캐시라인이 그 캐시메모리에 있어야 한다.
캐쉬라인은 128바이트로 넘어가지 않았다.
캐시라인? 한번에 캐시 메모리가 긁어오는 단위.
1바이트를 원해도 64바이트를 긁어온다.

일반적으로 언급하기 캐시히트를 높이기 위해선?

캐쉬 -> 변수를 뭔가 썼거나 읽었고 또 읽는다.
요렇게 했으면 코어에서 바로 물리메모리로 접근할 수 없다.
무조건 캐시메모리부터 파악하고 내려간다.
L1->L2->L3에 없다면 물리메모리에서 긁어온다.
근데 L1있으면 캐시히트.
캐쉬히트가 높이는게 성능이 아주좋아진다. 

캐쉬히트를 높이는 방법? 지역성 -> 가까이 있는걸 쓰자. 방금 썼던걸 또 쓰자.
가까이 있는걸 쓰면 왜 캐쉬히트가 높아져?
캐시메모리 설계할 때부터 근방에 접근할 일이 많더라.
그러니 그 주변에 있는걸 긁어버리자. 캐시 라인 단위로.
그 캐시라인이 64바이트.
A라는 변수 하나만 선언해도 걔가 속한 64바이트를 긁어온다. 물리메모리에서.
근데 어디로? a 뒤로 64? 앞으로 64?
64도 경계. 모든 메모리를 0바이트부터 64바이트로 끊어버림.
메모리가 0번지라는 상황에서 메모리가 있다면 64로 그리드를 쳐버리는 상황.
하나하나의 그리드가 캐쉬라인의 한 덩어리.
내 변수 하나가 캐쉬라인 하나에 걸쳤음-> 2개 긁어야 함. 이런 상황 무조건 피해야 함.
데이터의 깨짐!

MOV라는건 아토믹 연산자. MOV라는 명령어는 완료 될 때까지 멈추지 않는다.
OS의 개입이 없다. 개입이 있을 수가 없어. atomic 연산자기 떄문에.
우리 입장에서는 변수 하나를 가지고 올거야.
CPU입장에선 완벽히 한방에 처리한다.
근데 내부에서 할려다 보니까 캐시라인 2개를 긁어야 하네?
캐시라인에서 긁어오는 과정은 atomic하지 않다.
메모리의 atomic과 명령어의 atomic은 개념이 다르다.
명령어에서의 atomic은 인터럽트 없다. 이거 처리되는 과정에 하드웨어의 인터럽트 될수 없다.
명령어 입장에선 mov처리하기 전에 아예 안돌아온다. 
얘는 메모리로 돌아오고. 얘는 2덩어리로 얻어와야 비교가 된다. 

캐시라인은 64란게 동일하지만. 아키텍쳐에 따라서 32로 읽어오기/64비트로 읽어오기.
아키텍쳐마다 다르다.
요즘 아키텍쳐일수록 32. ? 캐시라인 64는 동일하지만.
인텔은 경계가 틀어지더라도 실제로는 64경계에만 끼지 않으면 데이터 쪼개지는 현상이 나타나지 않음.
AMD는 데이터 쪼개지는 현상이 나타남 32 경계만 있어도.

구조체의 전체 패딩은 왜맞추냐? 가장 큰걸로 왜 맞추는 거야?
-> 구조체 배열 때문에!!
클래스도 마찬가지. 클래스와 구조체가 동급!
크기를 가장 큰 녀석에 맞춘다. 그렇게 잡아줘야 내 다음 다음 뒤이어서 선언된 구조체에 문제가 없다. 


